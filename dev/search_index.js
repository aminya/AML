var documenterSearchIndex = {"docs":
[{"location":"SyntaxReference/","page":"Syntax Reference","title":"Syntax Reference","text":"","category":"page"},{"location":"SyntaxReference/#Main-Macro-and-IO","page":"Syntax Reference","title":"Main Macro and IO","text":"","category":"section"},{"location":"SyntaxReference/","page":"Syntax Reference","title":"Syntax Reference","text":"Modules = [AcuteML]\nPages   = [\"AcuteML.jl\",\"io.jl\"]","category":"page"},{"location":"SyntaxReference/#AcuteML.@aml-Tuple{Any}","page":"Syntax Reference","title":"AcuteML.@aml","text":"@aml\n\nType Definition\n\nUse @aml macro to define a Julia type, and then the package automatically creates a xml or html associated with the defined type. The general syntax would look like this:\n\n@aml mutable struct mybody \"body\"\n    myh1, \"h1\"\n    p::Vector{String}, \"~\"\nend\n\nYou can also define the structs as parametric:\n\n@aml mutable struct MyGeneralXML{T} \"my-general-xml\"\n    myfield::T, \"~\"\nend\npxml_string = MyGeneralXML{String}(myfield = \"a\")\npprint(pxml_string)\npxml_vector = MyGeneralXML{Vector{String}}(myfield = [\"b\",\"c\"])\npprint(pxml_vector)\n\nNow, we go into the details:\n\nDocument Definition\n\nUse doc literal before the root name to define a HTML or XML document. For HTML documents root should always be \"html\".\n\n@aml mutable struct Doc doc\"xml_root\"\n# add fields (elements) here\nend\n\n@aml mutable struct Web doc\"html\"\n# add fields (elements) here\nend\n\nNodes (Elements) Definition\n\nSpecify the html/xml name of struct as a string after the struct name (after a space)\n\n@aml mutable struct Person \"person\"\n# add fields (elements) here\nend\n\nIf the html/xml name is the same as struct name, you can use \"~\" instead\n\n@aml mutable struct person \"~\"\n# add fields (elements) here\nend\n\nFields Names\n\nSepecify the html/xml field name as a string in front of the field after ,\n\nfield, \"study-field\"\n\nIf the html/xml name is the same as variable name, you can use \"~\" instead\n\nage::UInt, \"~\"\n\nwarning: Warning\nThe field names of a struct should not be the same as other defined types. This error happens when you use the same name of a type for a field name. For example, the follwing is an error:@aml struct person \"~\"\n    name, \"~\"\nend\n@aml struct myxml doc\"~\"\n    person::person, \"~\"\nendAnother example of this error:@aml struct myxml doc\"~\"\n    Int, \"myint\"\nendHowever, you can choose any xml/html name. The xml/html name of the fields isn't related to the types defined in Julia. So the following is a valid syntax:@aml struct myxml doc\"~\"\n    myint, \"Int\"\nend\n\nAttributes\n\nIf the value is going to be an attribute put att before its name\n\nid::Int64, att\"~\"\n\nDefault Value\n\nYou can specify the default value for an argument by using = defVal syntax\n\nGPA::Float64 = 4.5, \"~\"\n\nValue Types\n\nYou can use Julia types or defined types for values. see and Supported Value Types  Custom Value Types for more information.\n\nIf you don't specify the type of a variable, it is considered to be string for aml manipulations:\n\nfield, \"study-field\"\n\nHowever, for a high performance code specify String type (field::String, \"study-field\")\n\nFor already @aml defined types, name should be the same as the defined type root name\n\nuniversity::University, \"university\"\n\nTable types are supported through PrettyTables.jl.\n\nValue Checking\n\nYou can define any restriction for values using functions.\n\nTo define any restrictions for the values of one field, define a function that checks a criteria for the field value and returns Bool, and put its name after a , after the field name:\n\nGPA::Float64, \"~\", GPAcheck\n\nTo define any restrictions for multiple values of a struct, define a function that gets all the variables and checks a criteria and returns Bool, and put its name after a , after the struct name:\n\n@aml mutable struct Person \"person\", check_course\n# ...\nend\n\nRefer to https://aminya.github.io/AcuteML.jl/dev/valueChecking/ for some of these functions examples.\n\nOptional Fields\n\nIf a field is optional, don't forget to define its type as UN{} (Union with Nothing), and set the default value as nothing.\n\nresidence::UN{String}=nothing, \"residence-stay\" # optional with nothing as default value\n\nfunds::UN{String}, \"financial-funds\"   # optional, but you should pass nothing manually in construction\n\nText Nodes\n\nIf the value is going to be in a Text node:\n\nuse txt\"index\" for non-vector field type, which index is an Integer that shows the positon of text node. If you give txt\"\" it considers it like txt\"1\".\n\ntextnode_single:String, txt\"2\"\n\nuse txt\"indices\" for vector field type, which indices is an array index that shows the positons of the text nodes. If you give txt\"\" it considers it like txt\"[:]\"\n\ntextnode_vector::Vector{String}, txt\"[2:3]\"\n\nNote that the vector Text nodes should only be used as the last field of a struct (because possible positons for text node should be known). Alternatively, you can make non-vector separate fields with correct position in the struct definition.\n\nEmpty Elements (Self-Closing) Definition\n\nUse empty\"name\" to define an empty (self-closing) element (e.g. <rest />)\n\n@aml struct rest empty\"~\"\nend\n\n\n\nExample - Simple\n\nusing AcuteML\n\n@aml mutable struct body \"~\"\n    h1, \"~\"\n    p::Vector{String}, \"~\"\nend\n\n@aml mutable struct html doc\"html\"\n    body::body, \"~\"\nend\n\nb = body(h1 = \"My heading\", p = [\"Paragraph1\", \"Paragraph2\"])\nd = html(body = b)\n\njulia> pprint(d)\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\">\n<html>\n  <body>\n    <h1>My heading</h1>\n    <p>Paragraph1</p>\n    <p>Paragraph2</p>\n  </body>\n </html>\n\n\n\nExample - Struct Definition\n\nFirst, we define the structs using @aml to store the data in:\n\nusing AcuteML\n\n# Types definition\n\n# Person Type\n@aml mutable struct Person \"person\", check_course\n    age::UInt64, \"~\"\n    field, \"study-field\"\n    GPA::Float64 = 4.5, \"~\", GPAcheck\n    courses::Vector{String}, \"taken-courses\"\n    professors::UN{DataFrame} = nothing, \"table\"\n    id::Int64, att\"~\"\n    comment::UN{String} = nothing, txt\"end\"\nend\n\n@aml mutable struct University doc\"university\"\n    name, att\"university-name\"\n    people::Vector{Person}, \"person\"\nend\n\n\n\n# Value Checking Functions\nGPAcheck(x) = x <= 4.5 && x >= 0\n\nfunction check_course(age, field, GPA, courses, professors, id, comment)\n\n    if field == \"Mechanical Engineering\"\n        relevant = [\"Artificial Intelligence\", \"Robotics\", \"Machine Design\"]\n    elseif field == \"Computer Engineering\"\n        relevant = [\"Julia\", \"Algorithms\"]\n    else\n        error(\"study field is not known\")\n    end\n\n    return any(in.(courses, Ref(relevant)))\nend\n\n\n\nExample - Creator\n\nAfter we defined the structs, we can create instances of them by passing our data to the fields:\n\n\nP1 = Person(age=24, field=\"Mechanical Engineering\", courses = [\"Artificial Intelligence\", \"Robotics\"], id = 1, comment = \"He is a genius\")\nP2 = Person(age=18, field=\"Computer Engineering\", GPA=4, courses=[\"Julia\"], id = 2)\n\nU = University(name=\"Julia University\", people=[P1, P2])\n\nU.people[2].GPA=4.2 # mutability support after Doc creation\n\n\n# An example that doesn't meet the criteria function for GPA because GPA is more than 4.5\nP3 = Person(age=99, field=\"Macro Wizard\", GPA=10, courses=[\"Julia Magic\"], id = 3)\njulia>\nGPA doesn't meet criteria function\n\njulia> pprint(P1) # or print(P1.aml)\n<person id=\"1\">\n  <age>24</age>\n  <study-field>Mechanical Engineering</study-field>\n  <GPA>4.5</GPA>\n  <taken-courses>Artificial Intelligence</taken-courses>\n  <taken-courses>Robotics</taken-courses>\n  He is a genius\n</person>\n\njulia> pprint(U) # or print(U.aml)\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<university university-name=\"Julia University\">\n  <person id=\"1\">\n    <age>24</age>\n    <study-field>Mechanical Engineering</study-field>\n    <GPA>4.5</GPA>\n    <taken-courses>Artificial Intelligence</taken-courses>\n    <taken-courses>Robotics</taken-courses>\n    He is a genius\n  </person>\n  <person id=\"2\">\n    <age>18</age>\n    <study-field>Computer Engineering</study-field>\n    <GPA>4.2</GPA>\n    <taken-courses>Julia</taken-courses>\n  </person>\n</university>\n\nP3 with Tables.jl type:\n\nProfs1 = DataFrame(course = [\"Artificial Intelligence\", \"Robotics\"], professor = [\"Prof. A\", \"Prof. B\"] )\n\nP3 = Person(age=24, field=\"Mechanical Engineering\", courses = [\"Artificial Intelligence\", \"Robotics\"], professors= Profs1, id = 1)\n\njulia> pprint(P3)\n\n<person id=\"1\">\n<age>24</age>\n<study-field>Mechanical Engineering</study-field>\n<GPA>4.5</GPA>\n<taken-courses>Artificial Intelligence</taken-courses>\n<taken-courses>Robotics</taken-courses>\n<table>\n<tr class=\"header\">\n<th style=\"text-align: right; \">course</th>\n<th style=\"text-align: right; \">professor</th>\n</tr>\n<tr class=\"subheader headerLastRow\">\n<th style=\"text-align: right; \">String</th>\n<th style=\"text-align: right; \">String</th>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Artificial Intelligence</td>\n<td style=\"text-align: right; \">Prof. A</td>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Robotics</td>\n<td style=\"text-align: right; \">Prof. B</td>\n</tr>\n</table>\n</person>\n\n\n\nExample - Extractor\n\nAfter we defined the structs, we can automatically extract and store the data in their fields:\n\nusing AcuteML\n\nxml = parsexml(\"\"\"\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<university university-name=\"Julia University\">\n  <person id=\"1\">\n    <age>24</age>\n    <study-field>Mechanical Engineering</study-field>\n    <GPA>4.5</GPA>\n    <taken-courses>Artificial Intelligence</taken-courses>\n    <taken-courses>Robotics</taken-courses>\n    He is a genius\n  </person>\n  <person id=\"2\">\n    <age>18</age>\n    <study-field>Computer Engineering</study-field>\n    <GPA>4.2</GPA>\n    <taken-courses>Julia</taken-courses>\n  </person>\n</university>\n\"\"\")\n\n# extract University\nU = University(xml) # StructName(xml) extracts the data and stores them in proper format\n\n# Now you can access all of the data by calling the fieldnames\n\njulia>U.name\n\"Julia University\"\n\n# extract Person\nP1 = U.people[1]\n\njulia>P1.age\n24\n\njulia>P1.field\nMechanical Engineering\n\njulia>P1.GPA\n4.5\n\njulia>P1.courses\n[\"Artificial Intelligence\", \"Robotics\"]\n\njulia>P1.id\n1\n\njulia> P1.comment\n\"He is a genius\"\n\n\n\n\n\n","category":"macro"},{"location":"SyntaxReference/#AcuteML.pprint-Union{Tuple{T}, Tuple{IO,T}} where T<:Union{Document, Node}","page":"Syntax Reference","title":"AcuteML.pprint","text":"pprint(x)\npprint(io, x)\npprint(filename, x)\n\nPretty prints the xml/html content of a aml type. Also, pretty prints a Node or Document type.\n\n\n\n\n\n","category":"method"},{"location":"SyntaxReference/#EzXML.parsehtml","page":"Syntax Reference","title":"EzXML.parsehtml","text":"parsehtml(htmlstring)\n\nParse htmlstring and create an HTML document.\n\n\n\n\n\n\n\n","category":"function"},{"location":"SyntaxReference/#EzXML.parsexml","page":"Syntax Reference","title":"EzXML.parsexml","text":"parsexml(xmlstring)\n\nParse xmlstring and create an XML document.\n\n\n\n\n\n\n\n","category":"function"},{"location":"SyntaxReference/#EzXML.readhtml","page":"Syntax Reference","title":"EzXML.readhtml","text":"readhtml(filename)\n\nRead filename and create an HTML document.\n\n\n\n\n\nreadhtml(input::IO)\n\nRead input and create an HTML document.\n\n\n\n\n\n\n\n","category":"function"},{"location":"SyntaxReference/#EzXML.readxml","page":"Syntax Reference","title":"EzXML.readxml","text":"readxml(filename)\n\nRead filename and create an XML document.\n\n\n\n\n\nreadxml(input::IO)\n\nRead input and create an XML document.\n\n\n\n\n\n\n\n","category":"function"},{"location":"SyntaxReference/#Templating","page":"Syntax Reference","title":"Templating","text":"","category":"section"},{"location":"SyntaxReference/","page":"Syntax Reference","title":"Syntax Reference","text":"Modules = [AcuteML]\nPages   = [\"templating.jl\"]","category":"page"},{"location":"SyntaxReference/#AcuteML.newTemplate","page":"Syntax Reference","title":"AcuteML.newTemplate","text":"newTemplate(name)\n\nCreate new destination html file as the template\n\nnewTemplate(name, :function)\n\nPrints a function to be used as a template\n\nExamples\n\n# you can create a file and edit the file directly by using\nnewTemplate(\"person\")\n\n## create person function to store out html template\nnewTemplate(\"person\", :function)\n\n\n\n\n\n","category":"function"},{"location":"SyntaxReference/#AcuteML.render2file","page":"Syntax Reference","title":"AcuteML.render2file","text":"render2file(destination, overwrite, var...)\n\nrender variables passed as an input to the destination file.\n\nYou should put var in the destination file/string so var is evaluated there. Pass the variables as keyword arguments with the same name you used in the html string/file. Variables should be string,\n\nIf you want to statically overwrite the file pass true as the 2nd argument to the function. Useful if you don't want a dynamic website.\n\nExamples\n\n# Add the following html code to the generated html file\n#=\n<person id=$(id)>\n  <age>$(age)</age>\n  <study-field>$(field)</study-field>\n  <GPA>$(GPA)</GPA>\n  <taken-courses>$(courses[1])</taken-courses>\n  <taken-courses>$(courses[2])</taken-courses>\n</person>\n=#\n\n# Specify the template (or its path), and also the variables for rendering\nout =render2file(\"person\", false,\n  id = 1,\n  age = 24,\n  field = \"Mechanical Engineering\",\n  GPA = 4.5,\n  courses = [\"Artificial Intelligence\", \"Robotics\"])\n\n# you pass `true` as the 2nd argument to owerwrite person.html statically.\n\n\n\n\n\n\n","category":"function"},{"location":"SyntaxReference/#Macro-Backend","page":"Syntax Reference","title":"Macro Backend","text":"","category":"section"},{"location":"SyntaxReference/","page":"Syntax Reference","title":"Syntax Reference","text":"Modules = [AcuteML]\nPages   = [\"aml_create.jl\", \"aml_parse.jl\", \"aml.jl\", \"args.jl\", \"literals.jl\"]","category":"page"},{"location":"SyntaxReference/#AcuteML.aml_create-Tuple{Expr,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}","page":"Syntax Reference","title":"AcuteML.aml_create","text":"@aml creator function\n\n\n\n\n\n","category":"method"},{"location":"SyntaxReference/#AcuteML.aml_parse-Tuple{Expr}","page":"Syntax Reference","title":"AcuteML.aml_parse","text":"@aml parser function\n\n\n\n\n\n","category":"method"},{"location":"SyntaxReference/#XML/HTML-utilities","page":"Syntax Reference","title":"XML/HTML utilities","text":"","category":"section"},{"location":"SyntaxReference/","page":"Syntax Reference","title":"Syntax Reference","text":"Modules = [AcuteML]\nPages   = [\"xmlutils.jl\", \"types.jl\", \"initializer.jl\", \"creators.jl\", \"extractors.jl\", \"updaters.jl\", \"amlDict.jl\", \"amlTables.jl\",\"amlTypesSupport.jl\"]","category":"page"},{"location":"SyntaxReference/#AcuteML.createnode","page":"Syntax Reference","title":"AcuteML.createnode","text":"createnode(struct_nodetype)\n\nFunction to initialize the aml\n\n\n\n\n\n","category":"function"},{"location":"templating/#Templating","page":"Templating","title":"Templating","text":"","category":"section"},{"location":"templating/","page":"Templating","title":"Templating","text":"AcuteML also provides a templating engine if you want to use templates instead of creating the types.","category":"page"},{"location":"templating/","page":"Templating","title":"Templating","text":"","category":"page"},{"location":"templating/#Template-Rendering-using-Functions","page":"Templating","title":"Template Rendering using Functions","text":"","category":"section"},{"location":"templating/","page":"Templating","title":"Templating","text":"This method only uses functions that return string. You can build your desired string and call the function for rendering.","category":"page"},{"location":"templating/","page":"Templating","title":"Templating","text":"## create person function to store out html template\nnewTemplate(\"person\", :function)\n\n\nfunction person(;id, age, field, GPA, courses)\n\n  # Build the taken courses section\n  loopOut=\"\"\n  for course in courses\n    loopOut = loopOut * \"\"\" <taken-courses>$(course)</taken-courses>   \"\"\"\n  end\n\n  # Append all the sections and variables together\n  out = \"\"\"\n  <person id=$(id)>\n    <age>$(age)</age>\n    <study-field>$(field)</study-field>\n    <GPA>$(GPA)</GPA>\n    $loopOut\n  </person>\n  \"\"\"\n\n  return out\nend\n\n# Call the function for rendering\nout = person(\n  id = \"1\",\n  age = \"24\",\n  field = \"Mechanical Engineering\",\n  GPA = \"4.5\",\n  courses = [\"Artificial Intelligence\", \"Robotics\"]\n)\n\nprint(out)\n\n# you can also write the output to a file:\nBase.write(filePath, out)","category":"page"},{"location":"templating/","page":"Templating","title":"Templating","text":"","category":"page"},{"location":"templating/#Template-Rendering-using-Files","page":"Templating","title":"Template Rendering using Files","text":"","category":"section"},{"location":"templating/","page":"Templating","title":"Templating","text":"You can render variables into html/xml files. However, you can't have multiline control flow Julia code in this method.","category":"page"},{"location":"templating/","page":"Templating","title":"Templating","text":"# you can create a file and edit the file directly by using\nnewTemplate(\"person\")\n\n# Add the following html code to the generated html file\n#=\n<person id=$(id)>\n  <age>$(age)</age>\n  <study-field>$(field)</study-field>\n  <GPA>$(GPA)</GPA>\n  <taken-courses>$(courses[1])</taken-courses>\n  <taken-courses>$(courses[2])</taken-courses>\n</person>\n=#\n\n# Specify the template (or its path), and also the variables for rendering\nout =render2file(\"person\", false,\n  id = 1,\n  age = 24,\n  field = \"Mechanical Engineering\",\n  GPA = 4.5,\n  courses = [\"Artificial Intelligence\", \"Robotics\"])\n\n# you pass `true` as the 2nd argument to owerwrite person.html statically.","category":"page"},{"location":"customValueTypes/#Custom-Value-Types","page":"Custom Value Types","title":"Custom Value Types","text":"","category":"section"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"In order to make a custom type work with @aml, you need to define two methods for your type:","category":"page"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"","category":"page"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"# String printing\nstring(x::yourType) = some_string_as_your_type_content\n\n# or\n\n# Node creation\naml(x::yourType) = a_Node","category":"page"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"","category":"page"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"# String parsing\nyourType(x::String) = a_type_made_from_a_string\n\n# or\n\n# Node parsing\nyourType(x::Node) = a_type_made_from_a_Node","category":"page"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"","category":"page"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"Date and Time types are supported through string printing and parsing. Tables compatible types are supported through Node creation and parsing. A combination of two options for each method is also possible.","category":"page"},{"location":"customValueTypes/#Example-String-printing-and-parsing:","page":"Custom Value Types","title":"Example - String printing and parsing:","text":"","category":"section"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"# Defining\nDate(2013,7,1)\n\n# Methods Check\nstring(Date(2013,7,1))\nDate(\"2013-7-1\")\n############################\n# Defining\nTime(12,53,40)\n\n# Methods Check\nstring(Time(12,53,40))\nTime(\"12:53:40\")\n############################\n# Defining\nDateTime(2013,5,1,12,53,40)\n\n# Methods Check\n# check\nstring(DateTime(2013,5,1,12,53,40))\nDateTime(\"2013-05-01T12:53:40\")","category":"page"},{"location":"customValueTypes/#Example-Node-creation-and-parsing:","page":"Custom Value Types","title":"Example - Node creation and parsing:","text":"","category":"section"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"You can directly create a Node using AcuteML utilities. See Custom Constructors for more information.","category":"page"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"You can also use a templating features of AcuteML to make a html as a string. For example, write a html_as_string function that returns the html as a string then, use findfirst(\"html/body/HeaderName\",parsehtml(str)) to parse it.","category":"page"},{"location":"customValueTypes/","page":"Custom Value Types","title":"Custom Value Types","text":"function aml(x::YourType)\n  str::Stirng = hmtl_as_string(x)\n\n  html = findfirst(\"html/body/HeaderName\",parsehtml(str))\n  unlink!(html)\n  return html\nend\n","category":"page"},{"location":"domxpath/#AcuteML-DOM/Xpath-API","page":"DOM/XPath API","title":"AcuteML DOM/Xpath API","text":"","category":"section"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"AcuteML provides a DOM/Xpath API that you can use to do lower level XML/HTML manipulation if needed.","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"You can use AcuteML utilities to define custom type constructors from scratch or to override @aml defined constructors.","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"Notice that if you don't use @aml, you should include aml::Node as one of your fields.","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"Functions to use for custom html/xml constructor:","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"createnode: function to create a node/document\naddnode! : To add nodes (single or a vector of nodes) as a child of given a node/document.","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"Use these functions, to make a method that calculates the aml inside the function and returns all of the fields.","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"Functions to use for custom html/xml extractor:","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"findfirst: to find the first node based on the given node name\nfindall: to find all of the nodes based on the given node name\nfindcontent : to get the content of a node based on the given name","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"Use these functions, to make a method that gets the aml::Node and calculates and returns all of the fields.","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"Functions to support mutability:","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"updatecontent!: Finds all the elements with the address of string in the node, and updates the content.","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"Additionally, all the EzXML API are reexported.","category":"page"},{"location":"domxpath/#Making-a-Type-and-constructor-from-scratch-using-AcuteML-Backend","page":"DOM/XPath API","title":"Making a Type and constructor from scratch using AcuteML Backend","text":"","category":"section"},{"location":"domxpath/#Example:","page":"DOM/XPath API","title":"Example:","text":"","category":"section"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"In this example we define Identity with custom constructors:","category":"page"},{"location":"domxpath/","page":"DOM/XPath API","title":"DOM/XPath API","text":"using AcuteML\n\nmutable struct Identity\n    pitch::UN{Pitch}\n    rest::UN{Rest}\n    unpitched::UN{Unpitched}\n    aml::Node\nend\n\nfunction Identity(;pitch = nothing, rest = nothing, unpitched = nothing)\n\n    # This constructor only allows one the fields to exist - similar to choice element in XS\n\n    aml = createnode(AbsNormal, \"identity\")\n\n    if pitch != nothing\n        addnode!(aml, \"pitch\", pitch, AbsNormal)\n    elseif rest != nothing\n        addnode!(aml, \"rest\", rest, AbsNormal)\n    elseif unpitched != nothing\n        addnode!(aml, \"unpitched\", unpitched, AbsNormal)\n    else\n        error(\"one of the pitch, rest or unpitched should be given\")\n    end\n\n    return Identity(pitch, rest, unpitched, aml)\nend\n\nfunction Identity(;aml)\n\n        pitch = findcontent(Pitch, \"pitch\", aml, AbsNormal)\n        rest = findcontent(Rest, \"rest\", aml, AbsNormal)\n        unpitched = findcontent(Unpitched, \"unpitched\", aml, AbsNormal)\n\n        return Identity(pitch, rest, unpitched, aml)\nend","category":"page"},{"location":"extraConstructors/#Extra-Constructors","page":"Extra Contructors","title":"Extra Constructors","text":"","category":"section"},{"location":"extraConstructors/#Constructors-on-top-of-@aml","page":"Extra Contructors","title":"Constructors on top of @aml","text":"","category":"section"},{"location":"extraConstructors/","page":"Extra Contructors","title":"Extra Contructors","text":"You can add constructors to your @aml defined type. In the function that you define you should return a call to the type with keywords assigned to the values.","category":"page"},{"location":"extraConstructors/#Example","page":"Extra Contructors","title":"Example","text":"","category":"section"},{"location":"extraConstructors/","page":"Extra Contructors","title":"Extra Contructors","text":"In the following example we define two custom constructors for our @aml defined struct.","category":"page"},{"location":"extraConstructors/","page":"Extra Contructors","title":"Extra Contructors","text":"\n# define a struct using @aml\n@aml struct Pitch \"pitch\"\n    step::String, \"step\"\n    alter::UN{Float16} = nothing, \"alter\"\n    octave::Int8, \"octave\"\nend","category":"page"},{"location":"extraConstructors/","page":"Extra Contructors","title":"Extra Contructors","text":"import MusicXML.pitch2xml  # some function from MusicXML.jl\n\n# 1st custom constructor:\nfunction Pitch(; pitch::Int64)\n\n    step, alter, octave = pitch2xml(pitch)\n\n    return Pitch(step = step, alter = alter, octave = octave) # return the main struct constructor with values assigned as keyword arguments\nend","category":"page"},{"location":"extraConstructors/","page":"Extra Contructors","title":"Extra Contructors","text":"# 2nd custom constructor:\nfunction Pitch(; step::String)\n\n    if step == \"C\"\n        octave = 0\n    else\n        octave = 10\n    end\n\n    return Pitch(step = step, octave = octave) # return the main struct constructor with values assigned as keyword arguments\nend\n","category":"page"},{"location":"customConstructors/#Custom-Constructors","page":"Custom Contructors","title":"Custom Constructors","text":"","category":"section"},{"location":"customConstructors/#Adding-Custom-code-to-the-structures","page":"Custom Contructors","title":"Adding Custom code to the structures","text":"","category":"section"},{"location":"customConstructors/","page":"Custom Contructors","title":"Custom Contructors","text":"AcuteML introduces three @creator, @extractor, and @updater macros to be used inside @aml definition. The location of the macros specifies their location in the function. For example, putting @creator at the begining, adds the code to begining of creator function.","category":"page"},{"location":"customConstructors/","page":"Custom Contructors","title":"Custom Contructors","text":"Put @creator inside @aml to add a custom code to the creator function (DOM creation when the struct is instanciated).\nThis macro only affects creation (not extraction/updating), but can be used in combination with other macros.\nPut @extractor inside @aml to add a custom code to the extractor function (DOM parsing when a html/xml text is used for instanciation of a struct).\nThis macro only affects creation (not creation/updating), but can be used in combination with other macros.\nBe careful that setting struct fields using @extractor only changes the struct field and not the xml code.\nPut @updater inside @aml to add a custom code to the updater function (DOM updating after instanciation of a struct).\nThis macro only affects updating (not creation/extraction), but can be used in combination with other macros.","category":"page"},{"location":"customConstructors/","page":"Custom Contructors","title":"Custom Contructors","text":"In the following example IQ and average are calculated automatically. Also, in the following example log is filled automatically (which doesn't have an associated xml element).","category":"page"},{"location":"customConstructors/","page":"Custom Contructors","title":"Custom Contructors","text":"using AcuteML\n# Definition\n@aml mutable struct Student \"student\"\n\n    # add custom code to the begining of creator function\n    # the following automatically fills IQ based on the name\n    @creator begin\n        if occursin(\"smart\", name)\n            name = replace(name, \"-smart\" => \"\") # remove smart from name\n            IQ = \"smart\"\n        elseif occursin(\"genius\", name)\n            name = replace(name, \"-genius\" => \"\") # remove smart from name\n            IQ = \"genius\"\n        else\n            error(\"Give a smart student.\")\n        end\n    end\n\n    name::String, \"~\"\n    GPA::Float64, \"~\"\n    IQ::UN{String} = nothing, att\"~\" # default to nothing, but filled automatically by first @cretor macro\n    # add custom code to the end of extractor function\n\n    log::UN{String} = nothing, \"~\"\n\n    @extractor begin\n        if GPA > 4.0\n            log = \"A genius with a GPA of $GPA is found\" # setting fields using @extractor only changes the field and not the xml code\n        end\n    end\nend\n\n@aml mutable struct MathClass \"math-class\"\n    @creator begin\n        GPAsum = 0.0\n        for student in students\n            GPAsum = GPAsum + student.GPA\n        end\n        average = GPAsum / length(students) # fill average field\n    end\n\n    students::Vector{Student}, \"student\"\n    average::UN{Float64} = nothing, \"average\" # calculated automatically\nend\n\n################################################################\n# Creation\nsmarts = [Student(name = \"Jack-smart\", GPA = 2.0), Student(name = \"Sara-genius\", GPA = 5.0)]\nmathclass = MathClass(students = smarts)\n\nmathclass.students[1].name # \"Jack\"\nmathclass.students[2].name # \"Sara\"\nmathclass.average # 3.5\n\npprint(mathclass)\n# <math-class>\n#     <student IQ=\"smart\">\n#       <name>Jack</name>\n#       <GPA>2.0</GPA>\n#     </student>\n#     <student IQ=\"genius\">\n#       <name>Sara</name>\n#       <GPA>5.0</GPA>\n#     </student>\n#     <average>3.5</average>\n#   </math-class>\n\n################################################################\n# Extraction\n\nxml = parsexml(\"\"\"\n<math-class>\n    <student>\n      <name>Jack</name>\n      <GPA>2.0</GPA>\n    </student>\n    <student>\n      <name>Sara</name>\n      <GPA>5.0</GPA>\n    </student>\n    <average>3.5</average>\n  </math-class>\n\"\"\")\n\nmathclass = MathClass(xml)\n\nmathclass.students[2].log # \"A genius with a GPA of 5.0 is found\"","category":"page"},{"location":"supportedValueTypes/#Supported-Value-Types","page":"Supported Value Types","title":"Supported Value Types","text":"","category":"section"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"You can use Julia types such as","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"String\nNumber\nBool\nDates and Time\nTables.jl compatible types\n...","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"In addition you can use your @aml defined types in another @aml definition.","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"see Custom Value Types for more information about all supported value types and custom value types.","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"","category":"page"},{"location":"supportedValueTypes/#@aml-defined-types","page":"Supported Value Types","title":"@aml defined types","text":"","category":"section"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"For already @aml defined types, name should be the same as the defined type root name","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"university::University, \"university\"","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"","category":"page"},{"location":"supportedValueTypes/#Tables","page":"Supported Value Types","title":"Tables","text":"","category":"section"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"AcuteML uses PrettyTables.jl to crate HTML from Table type data.","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"# Tables\nProfs1 = DataFrame(course = [\"Artificial Intelligence\", \"Robotics\"], professor = [\"Prof. A\", \"Prof. B\"] )\n\nP3 = Person(age=24, field=\"Mechanical Engineering\", courses = [\"Artificial Intelligence\", \"Robotics\"], professors= Profs1, id = 1)\n\npprint(P3)\n#=\n<person id=\"1\">\n<age>24</age>\n<study-field>Mechanical Engineering</study-field>\n<GPA>4.5</GPA>\n<taken-courses>Artificial Intelligence</taken-courses>\n<taken-courses>Robotics</taken-courses>\n<table>\n<tr class=\"header\">\n<th style=\"text-align: right; \">course</th>\n<th style=\"text-align: right; \">professor</th>\n</tr>\n<tr class=\"subheader headerLastRow\">\n<th style=\"text-align: right; \">String</th>\n<th style=\"text-align: right; \">String</th>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Artificial Intelligence</td>\n<td style=\"text-align: right; \">Prof. A</td>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Robotics</td>\n<td style=\"text-align: right; \">Prof. B</td>\n</tr>\n</table>\n</person>\n=#","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"","category":"page"},{"location":"supportedValueTypes/#Dates-and-Time:","page":"Supported Value Types","title":"Dates and Time:","text":"","category":"section"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"Date","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"Is covered under defined types, and it automatically is converted to the correct format","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"# Defining\nDate(2013,7,1)\nDate(\"2013-7-1\")","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"<some-date>YYYY-MM-DD</some-date>\n<some-date>2013-07-01</some-date>","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"Time","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"Is covered under defined types, and it automatically is converted to the correct format","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"# Defining\nTime(12,53,40)\nTime(\"12:53:40\")","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"<some-time>hh:mm:ss</some-time>\n<some-time>12:53:40</some-time>","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"DateTime","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"Is covered under defined types, and it automatically is converted to the correct format","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"# Defining\nDateTime(2013,5,1,12,53,40)\nDateTime(\"2013-05-01T12:53:40\")","category":"page"},{"location":"supportedValueTypes/","page":"Supported Value Types","title":"Supported Value Types","text":"<some-datatime>YYYY-MM-DDThh:mm:ss</some-datatime>\n<some-datatime>2013-05-01T12:53:40</some-datatime>","category":"page"},{"location":"valueChecking/#Value-Checking","page":"Value Checking","title":"Value Checking","text":"","category":"section"},{"location":"valueChecking/#Example-for-Common-Value-Restriction-functions","page":"Value Checking","title":"Example for Common Value Restriction functions","text":"","category":"section"},{"location":"valueChecking/","page":"Value Checking","title":"Value Checking","text":"Restrictions should be given as a function that returns Bool and the function checks for elements.","category":"page"},{"location":"valueChecking/","page":"Value Checking","title":"Value Checking","text":"For example, for a vector of strings:","category":"page"},{"location":"valueChecking/","page":"Value Checking","title":"Value Checking","text":"@aml struct Person \"person\"\n   member::Vector{String}, \"member\", memberCheck\nend","category":"page"},{"location":"valueChecking/","page":"Value Checking","title":"Value Checking","text":"Value limit check:","category":"page"},{"location":"valueChecking/","page":"Value Checking","title":"Value Checking","text":"memberCheck(x) = any( x>10 || x<5 )  # in a compact form: x-> any(x>10 || x<5)\n# x is all the values as a vector in this case","category":"page"},{"location":"valueChecking/","page":"Value Checking","title":"Value Checking","text":"Check of the length of the vector:","category":"page"},{"location":"valueChecking/","page":"Value Checking","title":"Value Checking","text":"memberCheck(x) = 0 < length(x) && length(x) < 10","category":"page"},{"location":"valueChecking/","page":"Value Checking","title":"Value Checking","text":"User should know if the vector is going to be 0-element, its type should be union with nothing, i.e., UN{}. This is because of the EzXML implementation of findfirst and findall.","category":"page"},{"location":"valueChecking/","page":"Value Checking","title":"Value Checking","text":"Set of valuse:","category":"page"},{"location":"valueChecking/","page":"Value Checking","title":"Value Checking","text":"setOfValues = [2,4,10]\nmemberCheck(x) = in.(x, setOfValues)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AcuteML","category":"page"},{"location":"#AcuteML","page":"Home","title":"AcuteML","text":"","category":"section"},{"location":"#Acute-Markup-Language","page":"Home","title":"Acute Markup Language","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AcuteML is an Acute Markup Language (AML) for Web/XML development in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It automatically creates or extracts HTML/XML files from Julia types!\nIt also has a general templating engine, which can be used for any type of documents.","category":"page"},{"location":"#Installation-and-Usage","page":"Home","title":"Installation and Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AcuteML\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"using AcuteML","category":"page"},{"location":"#Main-macro-and-I/O","page":"Home","title":"Main macro and I/O","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@aml","category":"page"},{"location":"#AcuteML.@aml","page":"Home","title":"AcuteML.@aml","text":"@aml\n\nType Definition\n\nUse @aml macro to define a Julia type, and then the package automatically creates a xml or html associated with the defined type. The general syntax would look like this:\n\n@aml mutable struct mybody \"body\"\n    myh1, \"h1\"\n    p::Vector{String}, \"~\"\nend\n\nYou can also define the structs as parametric:\n\n@aml mutable struct MyGeneralXML{T} \"my-general-xml\"\n    myfield::T, \"~\"\nend\npxml_string = MyGeneralXML{String}(myfield = \"a\")\npprint(pxml_string)\npxml_vector = MyGeneralXML{Vector{String}}(myfield = [\"b\",\"c\"])\npprint(pxml_vector)\n\nNow, we go into the details:\n\nDocument Definition\n\nUse doc literal before the root name to define a HTML or XML document. For HTML documents root should always be \"html\".\n\n@aml mutable struct Doc doc\"xml_root\"\n# add fields (elements) here\nend\n\n@aml mutable struct Web doc\"html\"\n# add fields (elements) here\nend\n\nNodes (Elements) Definition\n\nSpecify the html/xml name of struct as a string after the struct name (after a space)\n\n@aml mutable struct Person \"person\"\n# add fields (elements) here\nend\n\nIf the html/xml name is the same as struct name, you can use \"~\" instead\n\n@aml mutable struct person \"~\"\n# add fields (elements) here\nend\n\nFields Names\n\nSepecify the html/xml field name as a string in front of the field after ,\n\nfield, \"study-field\"\n\nIf the html/xml name is the same as variable name, you can use \"~\" instead\n\nage::UInt, \"~\"\n\nwarning: Warning\nThe field names of a struct should not be the same as other defined types. This error happens when you use the same name of a type for a field name. For example, the follwing is an error:@aml struct person \"~\"\n    name, \"~\"\nend\n@aml struct myxml doc\"~\"\n    person::person, \"~\"\nendAnother example of this error:@aml struct myxml doc\"~\"\n    Int, \"myint\"\nendHowever, you can choose any xml/html name. The xml/html name of the fields isn't related to the types defined in Julia. So the following is a valid syntax:@aml struct myxml doc\"~\"\n    myint, \"Int\"\nend\n\nAttributes\n\nIf the value is going to be an attribute put att before its name\n\nid::Int64, att\"~\"\n\nDefault Value\n\nYou can specify the default value for an argument by using = defVal syntax\n\nGPA::Float64 = 4.5, \"~\"\n\nValue Types\n\nYou can use Julia types or defined types for values. see and Supported Value Types  Custom Value Types for more information.\n\nIf you don't specify the type of a variable, it is considered to be string for aml manipulations:\n\nfield, \"study-field\"\n\nHowever, for a high performance code specify String type (field::String, \"study-field\")\n\nFor already @aml defined types, name should be the same as the defined type root name\n\nuniversity::University, \"university\"\n\nTable types are supported through PrettyTables.jl.\n\nValue Checking\n\nYou can define any restriction for values using functions.\n\nTo define any restrictions for the values of one field, define a function that checks a criteria for the field value and returns Bool, and put its name after a , after the field name:\n\nGPA::Float64, \"~\", GPAcheck\n\nTo define any restrictions for multiple values of a struct, define a function that gets all the variables and checks a criteria and returns Bool, and put its name after a , after the struct name:\n\n@aml mutable struct Person \"person\", check_course\n# ...\nend\n\nRefer to https://aminya.github.io/AcuteML.jl/dev/valueChecking/ for some of these functions examples.\n\nOptional Fields\n\nIf a field is optional, don't forget to define its type as UN{} (Union with Nothing), and set the default value as nothing.\n\nresidence::UN{String}=nothing, \"residence-stay\" # optional with nothing as default value\n\nfunds::UN{String}, \"financial-funds\"   # optional, but you should pass nothing manually in construction\n\nText Nodes\n\nIf the value is going to be in a Text node:\n\nuse txt\"index\" for non-vector field type, which index is an Integer that shows the positon of text node. If you give txt\"\" it considers it like txt\"1\".\n\ntextnode_single:String, txt\"2\"\n\nuse txt\"indices\" for vector field type, which indices is an array index that shows the positons of the text nodes. If you give txt\"\" it considers it like txt\"[:]\"\n\ntextnode_vector::Vector{String}, txt\"[2:3]\"\n\nNote that the vector Text nodes should only be used as the last field of a struct (because possible positons for text node should be known). Alternatively, you can make non-vector separate fields with correct position in the struct definition.\n\nEmpty Elements (Self-Closing) Definition\n\nUse empty\"name\" to define an empty (self-closing) element (e.g. <rest />)\n\n@aml struct rest empty\"~\"\nend\n\n\n\nExample - Simple\n\nusing AcuteML\n\n@aml mutable struct body \"~\"\n    h1, \"~\"\n    p::Vector{String}, \"~\"\nend\n\n@aml mutable struct html doc\"html\"\n    body::body, \"~\"\nend\n\nb = body(h1 = \"My heading\", p = [\"Paragraph1\", \"Paragraph2\"])\nd = html(body = b)\n\njulia> pprint(d)\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\">\n<html>\n  <body>\n    <h1>My heading</h1>\n    <p>Paragraph1</p>\n    <p>Paragraph2</p>\n  </body>\n </html>\n\n\n\nExample - Struct Definition\n\nFirst, we define the structs using @aml to store the data in:\n\nusing AcuteML\n\n# Types definition\n\n# Person Type\n@aml mutable struct Person \"person\", check_course\n    age::UInt64, \"~\"\n    field, \"study-field\"\n    GPA::Float64 = 4.5, \"~\", GPAcheck\n    courses::Vector{String}, \"taken-courses\"\n    professors::UN{DataFrame} = nothing, \"table\"\n    id::Int64, att\"~\"\n    comment::UN{String} = nothing, txt\"end\"\nend\n\n@aml mutable struct University doc\"university\"\n    name, att\"university-name\"\n    people::Vector{Person}, \"person\"\nend\n\n\n\n# Value Checking Functions\nGPAcheck(x) = x <= 4.5 && x >= 0\n\nfunction check_course(age, field, GPA, courses, professors, id, comment)\n\n    if field == \"Mechanical Engineering\"\n        relevant = [\"Artificial Intelligence\", \"Robotics\", \"Machine Design\"]\n    elseif field == \"Computer Engineering\"\n        relevant = [\"Julia\", \"Algorithms\"]\n    else\n        error(\"study field is not known\")\n    end\n\n    return any(in.(courses, Ref(relevant)))\nend\n\n\n\nExample - Creator\n\nAfter we defined the structs, we can create instances of them by passing our data to the fields:\n\n\nP1 = Person(age=24, field=\"Mechanical Engineering\", courses = [\"Artificial Intelligence\", \"Robotics\"], id = 1, comment = \"He is a genius\")\nP2 = Person(age=18, field=\"Computer Engineering\", GPA=4, courses=[\"Julia\"], id = 2)\n\nU = University(name=\"Julia University\", people=[P1, P2])\n\nU.people[2].GPA=4.2 # mutability support after Doc creation\n\n\n# An example that doesn't meet the criteria function for GPA because GPA is more than 4.5\nP3 = Person(age=99, field=\"Macro Wizard\", GPA=10, courses=[\"Julia Magic\"], id = 3)\njulia>\nGPA doesn't meet criteria function\n\njulia> pprint(P1) # or print(P1.aml)\n<person id=\"1\">\n  <age>24</age>\n  <study-field>Mechanical Engineering</study-field>\n  <GPA>4.5</GPA>\n  <taken-courses>Artificial Intelligence</taken-courses>\n  <taken-courses>Robotics</taken-courses>\n  He is a genius\n</person>\n\njulia> pprint(U) # or print(U.aml)\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<university university-name=\"Julia University\">\n  <person id=\"1\">\n    <age>24</age>\n    <study-field>Mechanical Engineering</study-field>\n    <GPA>4.5</GPA>\n    <taken-courses>Artificial Intelligence</taken-courses>\n    <taken-courses>Robotics</taken-courses>\n    He is a genius\n  </person>\n  <person id=\"2\">\n    <age>18</age>\n    <study-field>Computer Engineering</study-field>\n    <GPA>4.2</GPA>\n    <taken-courses>Julia</taken-courses>\n  </person>\n</university>\n\nP3 with Tables.jl type:\n\nProfs1 = DataFrame(course = [\"Artificial Intelligence\", \"Robotics\"], professor = [\"Prof. A\", \"Prof. B\"] )\n\nP3 = Person(age=24, field=\"Mechanical Engineering\", courses = [\"Artificial Intelligence\", \"Robotics\"], professors= Profs1, id = 1)\n\njulia> pprint(P3)\n\n<person id=\"1\">\n<age>24</age>\n<study-field>Mechanical Engineering</study-field>\n<GPA>4.5</GPA>\n<taken-courses>Artificial Intelligence</taken-courses>\n<taken-courses>Robotics</taken-courses>\n<table>\n<tr class=\"header\">\n<th style=\"text-align: right; \">course</th>\n<th style=\"text-align: right; \">professor</th>\n</tr>\n<tr class=\"subheader headerLastRow\">\n<th style=\"text-align: right; \">String</th>\n<th style=\"text-align: right; \">String</th>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Artificial Intelligence</td>\n<td style=\"text-align: right; \">Prof. A</td>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Robotics</td>\n<td style=\"text-align: right; \">Prof. B</td>\n</tr>\n</table>\n</person>\n\n\n\nExample - Extractor\n\nAfter we defined the structs, we can automatically extract and store the data in their fields:\n\nusing AcuteML\n\nxml = parsexml(\"\"\"\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<university university-name=\"Julia University\">\n  <person id=\"1\">\n    <age>24</age>\n    <study-field>Mechanical Engineering</study-field>\n    <GPA>4.5</GPA>\n    <taken-courses>Artificial Intelligence</taken-courses>\n    <taken-courses>Robotics</taken-courses>\n    He is a genius\n  </person>\n  <person id=\"2\">\n    <age>18</age>\n    <study-field>Computer Engineering</study-field>\n    <GPA>4.2</GPA>\n    <taken-courses>Julia</taken-courses>\n  </person>\n</university>\n\"\"\")\n\n# extract University\nU = University(xml) # StructName(xml) extracts the data and stores them in proper format\n\n# Now you can access all of the data by calling the fieldnames\n\njulia>U.name\n\"Julia University\"\n\n# extract Person\nP1 = U.people[1]\n\njulia>P1.age\n24\n\njulia>P1.field\nMechanical Engineering\n\njulia>P1.GPA\n4.5\n\njulia>P1.courses\n[\"Artificial Intelligence\", \"Robotics\"]\n\njulia>P1.id\n1\n\njulia> P1.comment\n\"He is a genius\"\n\n\n\n\n\n","category":"macro"}]
}
